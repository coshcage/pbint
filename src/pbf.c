/*
 * Name:		pbf.c
 * Description: Portable big integer FFT multiplication support.
 * Author:	    cosh.cage#hotmail.com
 *              This file is partially generated by Copilot AI.
 * File ID:	    0917252155B0918251122L00200
 * License:	    GPLv3.
 * Caution:     Link this file with -lm parameter on gcc.
 *
 * Note: This file provides an FFT-based multiplication for big integers in binary format using the BINT structure.
 *	   This implementation uses iterative FFT (Cooley-Tukey) and double precision (not cryptographically secure).
 */
#include <stdlib.h> /* Use function calloc, free. */
#include <math.h>   /* Use function sin, cos. */
#include "pbk.h"

/* Define double constant PI. */
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* File scope function declaration. */
static void _pbfFFTTransform(double * real, double * imag, size_t n, _boolean binv);

/* Attention:     This Is An Internal Function. No Interface for Library Users.
 * Function name: _pbfFFTTransform
 * Description:   Fast Fourier Transform.
 * Parameters:
 *       real Pointer to real part array.
 *       imag Pointer to image part array.
 *          n The length of complex array.
 *       binv TRUE: Inverse transform. FALSE: Forward transform.
 * Return value:  N/A.
 */
static void _pbfFFTTransform(double * real, double * imag, size_t n, _boolean binv)
{
	register size_t i, j, len;
	/* Bit reversal permutation. */
	size_t bits = 0;
	for (len = n; len > 1; len >>= 1)
		++bits;
	for (i = 0; i < n; ++i)
	{
		register size_t rev = 0;
		for (j = 0; j < bits; ++j)
		{
			if (i & (1 << j))
				rev |= 1 << (bits - 1 - j);
		}
		if (rev > i)
		{
			register double tmp = real[i];
			real[i] = real[rev];
			real[rev] = tmp;
			
			tmp = imag[i];
			imag[i] = imag[rev];
			imag[rev] = tmp;
		}
	}

	for (len = 2; len <= n; len <<= 1)
	{
		register double ang = 2 * M_PI / len * (binv ? -1 : 1);
		register double wlen_real = cos(ang), wlen_imag = sin(ang);
		for (i = 0; i < n; i += len)
		{
			register size_t k = len >> 1;
			register double w_real = 1, w_imag = 0;
			for (j = 0; j < k; ++j)
			{
				register size_t u = i + j, v = i + j + k;
				register double r = real[v] * w_real - imag[v] * w_imag;
				register double im = real[v] * w_imag + imag[v] * w_real;
				register double next_w_real;
				real[v] = real[u] - r;
				imag[v] = imag[u] - im;
				real[u] += r;
				imag[u] += im;
				next_w_real = w_real * wlen_real - w_imag * wlen_imag;
				w_imag = w_real * wlen_imag + w_imag * wlen_real;
				w_real = next_w_real;
			}
		}
	}
	if (binv)
	{
		for (i = 0; i < n; ++i)
		{
			real[i] /= n;
			imag[i] /= n;
		}
	}
}

/*
 * Function name: pbkMultiplyBintFFT
 * Description:   Multiplies two big integers using FFT and stores result to c.
 * Parameters:
 *          c Pointer to a big integer.
 *          a Pointer to a big integer.
 *          b Pointer to a big integer.
 * Return value: TRUE:  Succeeded.
 *               FALSE: Failed.
 * Caution:      The address of c shall not equal to a or b.
 * Tip:          c := a * b;
 */
_boolean pbkMultiplyBintFFT(P_BINT c, P_BINT a, P_BINT b)
{
	if (pbkIsNotANumber(a) || pbkIsNotANumber(b))
		return FALSE;
	else
	{
		register _udb carry;
		register size_t clen;
		register size_t i;
		_ib sign_a = GETFLAG(a) >= 0 ? 1 : -1;
		_ib sign_b = GETFLAG(b) >= 0 ? 1 : -1;
		register size_t len_a = GETABS(GETFLAG(a));
		register size_t len_b = GETABS(GETFLAG(b));
		double * A, * B, * Ai, * Bi;
		
		if (len_a == 0 || len_b == 0)
			return pbkIbToBint(c, 0);

		/* Find the smallest power of two >= len_a + len_b. */
		size_t n = 1;
		while (n < len_a + len_b)
			n <<= 1;

		/* Allocate FFT arrays. */
		A = (double *)calloc(4 * n, sizeof(double));
		
		if (!A)
			return FALSE;
		
		B = A + n;
		Ai = B + n;
		Bi = Ai + n;

		/* Copy integer blocks to double arrays. */
		for (i = 0; i < len_a; ++i)
			A[i] = (double)a->data[i];
		for (i = 0; i < len_b; ++i)
			B[i] = (double)b->data[i];

		/* Forward FFT. */
		_pbfFFTTransform(A, Ai, n, FALSE);
		_pbfFFTTransform(B, Bi, n, FALSE);

		/* Pointwise multiplication. */
		for (i = 0; i < n; ++i)
		{
			register double real = A[i] * B[i] - Ai[i] * Bi[i];
			register double imag = A[i] * Bi[i] + Ai[i] * B[i];
			A[i] = real;
			Ai[i] = imag;
		}

		/* Inverse FFT. */
		_pbfFFTTransform(A, Ai, n, TRUE);

		/* Prepare result. */
		if (!pbkReallocBint(c, n, TRUE))
		{
			free(A);
			return FALSE;
		}

		carry = 0;
		for (i = 0; i < n; ++i)
		{	/* Rounding for floating-point error. */
			register _udb val = (_udb)(A[i] + 0.5) + carry;
			c->data[i] = (_ub)(val & UBLOCK_FULL);
			carry = val >> UB_BIT;
		}

		/* Handle remaining carry. */
		clen = n;
		while (carry)
		{
			if (clen >= GETSIZE(c))
			{
				if (!pbkReallocBint(c, clen + 1, TRUE))
					break;
			}
			c->data[clen++] = (_ub)(carry & UBLOCK_FULL);
			carry >>= UB_BIT;
		}

		/* Remove leading zeros. */
		while (clen > 1 && 0 == c->data[clen - 1])
			--clen;
		SETFLAG(c, (_ib)clen * sign_a * sign_b);

		free(A);
	}
	return TRUE;
}

